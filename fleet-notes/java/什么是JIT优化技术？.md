---
title: 什么是JIT优化技术？
tags:
  - fleet-note
  - programming-language/java/jvm
date: 2024-12-09
time: 19:15
aliases:
---
JVM 内置了解释器和编译器，JVM 开始执行使用解释器解释执行，但是当 JVM 发现某个方法或者代码块运行频率高的时候，就会认为是热点代码（Hotspot Code），JIT 即时编译器会把这部分热点代码翻译成本地的机器代码进行调用，加快执行速度。

Hotspot 内置了两个 JIT 编译器，Client 和 Server。

## 热点检测

识别热点代码有两种方式：
1. 基于采样的方式（Sample Based Hotspot Detection）：周期性检测线程栈顶，如果某个方法经常出现在栈顶，就认为是热点代码，实现简单，但无法精准确定代码热度，容易受到线程阻塞等的干扰
2. 基于计数器的方式（Counter Based Hotspot Detection）：每个方法、代码块设立计数器，统计执行次数，如果超过阈值就认为是热点方法。

HotSpot 虚拟机的 JIT（Just-In-Time）编译器进行热点代码检测主要依赖于两种探测方法：基于采样的热点探测和基于计数器的热点探测。在 HotSpot 中，具体采用的是基于计数器的热点探测方法。这种方法通过为每个方法准备两个计数器——方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）来实现。

1. **方法调用计数器**：
   - 用于统计方法被直接调用的次数。
   - 在 Client 模式下，如果一个方法被调用了超过 1500 次，在 Server 模式下超过 10000 次，则该方法被视为热点代码，并触发即时编译。

2. **回边计数器**：
   - 回边计数器用来统计循环体执行的次数，它针对的是循环结构中的代码。当遇到字节码中的控制流向后跳转指令（即“回边”）时，会增加此计数器。
   - 对于 Client 模式，回边计数器阈值大约是 13995；对于 Server 模式，这个数值约为 10700。这些阈值根据 OSR 比率等参数计算得出。

此外，为了防止不常使用的代码占用过多资源，HotSpot 还实现了方法调用计数器热度衰减机制。如果一段代码在一定时间内没有达到触发即时编译的条件，它的计数器值会被减半，这段时间称为半衰周期（Counter Half Life Time）。默认情况下，热度衰减是在垃圾收集期间发生的，但可以通过参数 `-XX:-UseCounterDecay` 关闭此行为。

当任何一个计数器超过了其设定的阈值时，HotSpot 就会认为相应的代码是热点代码，并启动即时编译过程，将 Java 字节码转换为优化后的本地机器码，以提高执行效率。这种编译可以在方法执行的过程中发生，这被称为栈上替换（On Stack Replacement, OSR），即使得正在执行的方法可以被新的、更高效的版本所取代。

# 编译优化

JIT 还有很多的优化，如下：
* [逃逸分析](逃逸分析)
* 标量替换
* 栈上分配
* 锁消除、锁膨胀
* 方法内联
* 空值检查消除
* 类型检测消除
* 公共子表达式消除

# 编译优化带来的问题

JIT 是运行期间进行的，因此当程序刚启动时，都需要解释执行，一旦解释器对 CPU 占用资源比较大时，会导致应用性能进一步下降，所以很多应用发布时，会出现刚刚重启好的应用会发生大量的超时问题。

随着请求的不断增多，JIT 热点代码就会被触发，直接运行机器码了。

如何解决？
* 提升 JIT 的优化效率
* 预热

例如阿里研发的 JDK（[Dragonwell](https://github.com/dragonwell-project/dragonwell8/wiki/Alibaba-Dragonwell8-User-Guide#jwarmup)）, 提供了 JwarmUp，通过记录上一次运行时的编译信息到文件中，下次启动时直接读取该文件，提前完成类的加载、初始化和方法编译，跳过解释阶段，直接执行机器码。

也可以使用预热技术，在应用刚启动时，通过 LB 分发少量流量给他，通过这一部分流量触发 JIT 优化，等优化好之后，再把流量调大。



# Reference