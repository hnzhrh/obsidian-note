---
title: Redis Master 和 Replica 如何处理过期数据？
tags:
  - permanent-note
  - middleware/redis/eviction
date: 2025-03-10
time: 19:30
aliases: 
done: false
---
# 主从架构会读取到过期数据吗？

由于 [Redis 过期数据处理机制](Redis%20过期数据处理机制.md) ，且Replica 不会执行定期删除和惰性删除，在 3.2 版本之前，从库在服务读请求时，并不会判断数据是否过期，而是会返回过期数据，如果在 3.2 版本之后，如果数据过期了，从库虽然不会进行删除，但会返回空值，避免客户端读取到过期数据。

3.2 版本后也是有可能会读取到过期数据的，因为主从同步的异步导致从库数据的过期时间可能延后。

Redis 有两种类型的过期命令：
* `EXPIRE <key> <ttl>`
* `EXPIREAT <key> <timestamp>`
当主库执行了 `EXPIRE Key ttl` 之后，主从同步发送给从库执行，从库执行时的过期时间就是当前时间加 `ttl` 了，如此从库的过期时间就比主库延后了。

可以使用 `EXPIREAT` 设置时间点来尽可能规避，但主从服务器时钟要一致（NTP 同步）。

# 从库如何处理过期数据的？

* 从库不会主动删除过期的 Key，如果主库过期删除了 Key 或者由于内存淘汰策略删除了 Key 都会同步 `DEL` 命令给从库进行删除键
* 在 `DEL` 命令到来之前，3.2 版本之前从库依然能读到该数据，3.2 版本之后，从库还会判断过期时间，如果已经过期会返回空值，从库也不会进行删除，而是等待主库的 `DEL` 命令
* `Lua` 脚本执行期间，不会去进行任何过期键的删除，防止键在脚本执行过程中过期的问题


# Reference
* [32 \| Redis主从同步与故障切换，有哪些坑？-Redis核心技术与实战-极客时间](https://time.geekbang.org/column/article/303247)