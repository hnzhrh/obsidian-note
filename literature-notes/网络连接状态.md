---
title: 网络连接状态
tags:
  - literature-note
  - network
date: 2025-03-03
time: 15:51
aliases:
---


> 嗯，我现在需要弄清楚在netstat命令中，HTTP连接会有哪些状态。首先，我应该回忆一下netstat的作用，它是用来显示网络连接、路由表、接口统计等信息的工具。而HTTP是基于TCP的，所以可能这些状态其实是TCP的连接状态，而不是HTTP特有的。不过用户问的是HTTP的连接状态，可能他们指的是在HTTP通信过程中，通过netstat看到的TCP状态。
> 
> 我记得TCP连接有几个标准的状态，比如ESTABLISHED、LISTEN、SYN_SENT、SYN_RECEIVED、FIN_WAIT1、FIN_WAIT2、TIME_WAIT、CLOSE_WAIT、LAST_ACK、CLOSED等。那这些状态中，哪些在HTTP请求处理过程中比较常见呢？
> 
> 比如，当服务器监听HTTP请求时，对应的端口应该是LISTEN状态。客户端发起连接时，可能先发送SYN，处于SYN_SENT状态，服务器收到后进入SYN_RECEIVED，然后建立连接后的ESTABLISHED。当连接关闭时，可能会有FIN_WAIT、TIME_WAIT、CLOSE_WAIT等状态。
> 
> 不过用户特别提到的是HTTP的连接状态，可能有一些特定的状态需要注意。例如，在HTTP/1.1中，可能会使用持久连接，所以连接保持ESTABLISHED一段时间，而不是立即关闭。而在服务器处理完请求后，如果客户端发起了关闭，服务器可能处于CLOSE_WAIT状态，等待自己关闭连接。客户端在主动关闭后，可能进入FIN_WAIT或TIME_WAIT状态。
> 
> 另外，需要注意，有时候连接卡在某个状态可能表示有问题。比如大量的CLOSE_WAIT可能意味着应用程序没有正确关闭连接，而大量的TIME_WAIT则可能在高负载的服务器上出现，属于正常现象，但过多可能需要调整内核参数。
> 
> 所以总结一下，HTTP的连接状态其实是TCP的状态，常见的包括LISTEN（服务器监听）、ESTABLISHED（已建立连接）、TIME_WAIT（等待关闭）、CLOSE_WAIT（等待本地关闭）等。可能还需要解释每个状态的意义，以及它们在HTTP通信中的表现。
> 
> 不过有没有可能遗漏某些状态？比如SYN_RECEIVED，在服务器收到SYN但未完成三次握手时出现，这时候可能涉及SYN洪水攻击，但正常情况可能较少见。另外，LAST_ACK状态是服务器发送FIN后等待确认，这时候连接即将关闭。
> 
> 所以用户的问题其实是关于netstat中与HTTP相关的TCP连接状态，应该列出常见的TCP状态，并说明它们在HTTP中的情况。例如，服务器端LISTEN，客户端和服务器建立连接后的ESTABLISHED，关闭时的各个状态。同时可能需要强调HTTP本身不定义状态，这些状态属于TCP层，但HTTP使用TCP，所以在HTTP通信中会看到这些状态。
> 
> 另外，可能需要注意，像TIME_WAIT状态出现在主动关闭连接的一方，通常是客户端，但如果是服务器主动关闭，比如HTTP/1.0的非持久连接，服务器在发送响应后关闭连接，这时候服务器会进入TIME_WAIT。不过一般来说，客户端更多执行主动关闭，所以TIME_WAIT可能出现在客户端。
> 
> 不过实际情况中，比如在HTTP服务器上，如果服务器配置为主动关闭连接，可能看到较多的TIME_WAIT状态。例如，当使用某些负载均衡器或反向代理时，可能调整这种行为。
> 
> 总结，应该整理出常见的TCP状态，并说明它们在HTTP通信中的意义。例如：
> 
> - LISTEN：服务器正在监听端口，等待连接。
> 
> - SYN_SENT：客户端发送SYN，等待服务器响应。
> 
> - SYN_RECEIVED：服务器收到SYN，发送SYN-ACK。
> 
> - ESTABLISHED：连接已建立，数据传输中。
> 
> - FIN_WAIT1：主动关闭方发送FIN，等待ACK。
> 
> - FIN_WAIT2：收到对FIN的ACK，等待对方的FIN。
> 
> - TIME_WAIT：完成主动关闭，等待足够时间以确保对方收到ACK。
> 
> - CLOSE_WAIT：被动关闭方收到FIN，等待应用关闭连接。
> 
> - LAST_ACK：被动关闭方发送FIN，等待ACK后关闭。
> 
> - CLOSED：连接已关闭。
> 
> 然后针对HTTP的情况，比如服务器处于LISTEN，客户端和服务器建立连接后ESTABLISHED，关闭时根据哪一方先关闭进入不同状态。例如，客户端完成请求后关闭，进入TIME_WAIT，服务器可能处于CLOSE_WAIT直到应用层处理完毕并关闭连接。
> 
> 可能还需要解释一些常见的问题状态，比如大量CLOSE_WAIT可能意味着服务器程序没有正确关闭socket，导致资源泄漏；大量TIME_WAIT则是正常现象，但过多可能消耗端口资源。
> 
> 因此，用户的问题答案应该是列出这些TCP状态，并说明它们在HTTP连接中的上下文。
> 
> 在 `netstat` 命令中，HTTP 连接的状态实际上是 **TCP 层的连接状态**（HTTP 本身不定义连接状态，而是依赖底层的 TCP 协议）。以下是常见的 TCP 状态及其在 HTTP 通信中的含义：

---

### 1. **LISTEN**
- **含义**：服务器正在监听端口，等待客户端的连接请求（如 HTTP 默认端口 80 或 443）。
- **HTTP 场景**：Web 服务器（如 Nginx、Apache）启动后，会处于 `LISTEN` 状态，准备接收客户端请求。

---

### 2. **SYN_SENT**
- **含义**：客户端发送连接请求（SYN 包），等待服务器确认。
- **HTTP 场景**：当浏览器（客户端）尝试连接服务器时，会短暂进入此状态。

---

### 3. **SYN_RECEIVED**
- **含义**：服务器收到客户端的 SYN 包并回复 SYN-ACK 包，等待客户端最终确认。
- **HTTP 场景**：服务器处理新连接请求时的中间状态，通常短暂存在。

---

### 4. **ESTABLISHED**
- **含义**：连接已建立，双方可以正常传输数据。
- **HTTP 场景**：客户端与服务器成功建立 TCP 连接后，HTTP 请求和响应在此状态下进行。

---

### 5. **FIN_WAIT 1 / FIN_WAIT 2**
- **含义**：主动关闭连接的一方（如客户端）发送 FIN 包后进入 `FIN_WAIT1`，收到对方 ACK 后进入 `FIN_WAIT2`，等待对方的 FIN 包。
- **HTTP 场景**：当客户端或服务器主动关闭连接时触发（如 HTTP/1.0 的非持久连接）。

---

### 6. **TIME_WAIT**
- **含义**：主动关闭方在发送最后一个 ACK 后进入此状态，等待足够时间（2*MSL，通常 1-4 分钟）以确保对方收到确认。
- **HTTP 场景**：频繁短连接的客户端或服务器（如高并发服务）可能积累大量 `TIME_WAIT` 状态。

---

### 7. **CLOSE_WAIT**
- **含义**：被动关闭方（如服务器）收到对方的 FIN 包后进入此状态，等待应用程序关闭连接。
- **HTTP 场景**：若服务器未正确关闭 Socket（如代码未调用 `close()`），会导致 `CLOSE_WAIT` 堆积，可能引发资源泄漏。

---

### 8. **LAST_ACK**
- **含义**：被动关闭方发送自己的 FIN 包后，等待对方最后的 ACK。
- **HTTP 场景**：服务器完成数据发送并主动关闭连接时的中间状态。

---

### 9. **CLOSED**
- **含义**：连接已完全关闭，无状态保留。
- **HTTP 场景**：连接终止后的最终状态。

---

### 常见问题与排查
- **大量 `TIME_WAIT`**：常见于高并发短连接场景，可通过调整内核参数（如 `net.ipv4.tcp_tw_reuse`）优化。
- **大量 `CLOSE_WAIT`**：通常为程序 Bug（如未正确释放连接），需检查代码逻辑。
- **长时间 `SYN_RECEIVED`**：可能是 SYN 洪水攻击或服务器负载过高。

---

### 总结
HTTP 依赖 TCP 连接，因此通过 `netstat` 观察到的状态本质是 TCP 状态。理解这些状态有助于排查连接泄漏、性能瓶颈及网络攻击等问题。