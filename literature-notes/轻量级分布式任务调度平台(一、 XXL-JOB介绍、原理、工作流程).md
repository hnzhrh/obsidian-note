---
title: "轻量级分布式任务调度平台(一、 XXL-JOB介绍、原理、工作流程)"
tags:
  - "clippings literature-note"
date: 2025-02-26
time: 2025-02-26T17:32:33+08:00
source: "https://www.cnblogs.com/MrYuChen-Blog/p/14804019.html"
---
## XXL-JOB#

**【轻量级分布式任务调度平台】**

## (1) 基本介绍#

**`XXL-JOB`是一个轻量级分布式任务调度平台，主打特点是平台化，易部署，开发迅速、学习简单、轻量级、易扩展，代码仍在持续更新中。**

- `调度中心`: **任务调度控制台，平台自身并不承担业务逻辑，只是负责任务的统一管理和调度执行，并且提供任务管理平台**
- `执行器`: **负责接收“调度中心”的调度并执行，可直接部署执行器，也可以将执行器集成到现有业务项目中。 通过将任务的调度控制和任务的执行解耦，业务使用只需要关注业务逻辑的开发。**
- `XXL-JOB`主要提供了**任务的动态配置管理、任务监控和统计报表以及调度日志**几大功能模块，**支持多种运行模式和路由策略，可基于对应执行器机器集群数量进行简单分片数据处理**。

## (2) 框架源码及文档#

**源码地址：**

- [GitHub](https://github.com/xuxueli/xxl-job)
- [码云](https://gitee.com/xuxueli0323/xxl-job)

**文档地址：**

- [中文文档](http://www.xuxueli.com/xxl-job/#/)
- [英文文档](http://www.xuxueli.com/xxl-job/en/#/)

## (3)XXL-JOB的特性#

- 1、**简单**：支持通过`Web页面`对任务进行`CRUD`操作，*操作简单*，一分钟上手；
- 2、**动态**：支持\_动态修改任务状态、启动/停止任务，以及终止运行中任务，即时生效\_；
- 3、**调度中心HA（中心式）**：调度采用`中心式设计`，调度中心自研调度组件并`支持集群部署`，可保证调度中心HA；
- 4、**执行器HA（分布式)**：任务分布式执行，任务"执行器"支持集群部署，可保证任务执行HA；
- 5、**注册中心**: 执行器会周期性自动注册任务, 调度中心将会自动发现注册的任务并触发执行。也支持手动录入执行器地址；
- 6、**弹性扩容缩容**：一旦有新执行器机器上线或者下线，下次调度时将会重新分配任务；
- 7、**路由策略**：执行器集群部署时提供丰富的路由策略，包括：\_**第一个、最后一个、轮询、随机、一致性HASH、最不经常使用、最近最久未使用、故障转移、忙碌转移**\_等；
- 8、**故障转移**：任务路由策略选择\_**故障转移**\_情况下，如果执行器集群中某一台机器故障，将会自动Failover切换到一台正常的执行器发送调度请求。
- 9、**阻塞处理策略**：调度过于密集执行器来不及处理时的处理策略，策略包括：***单机串行（默认）、丢弃后续调度、覆盖之前调度***；
- 10、**任务超时控制**：支持\_**自定义任务超时时间**\_，任务运行超时将会主动中断任务；
- 11、**任务失败重试**：支持\_**自定义任务失败重试次数**\_，当任务失败时将会按照预设的失败重试次数主动进行重试；其中分片任务支持分片粒度的失败重试；
- 12、**任务失败警告**：默认提供邮件方式失败告警，同时预留扩展接口，可方便的扩展短信、钉钉等告警方式；
- 13、**分片广播任务**：执行器集群部署时，任务路由策略选择`分片广播`情况下，一次任务调度将会广播触发集群中所有执行器执行一次任务，可根据分片参数开发分片任务；
- 14、**动态分片**：分片广播任务以执行器为维度进行分片，支持动态扩容执行器集群从而动态增加分片数量，协同进行业务处理；在进行大数据量业务操作时可显著提升任务处理能力和速度。
- 15、**事件触发**：除了`Cron方式`和`任务依赖方式`触发任务执行之外，支持基于事件的触发任务方式。调度中心提供触发任务单次执行的API服务，可根据业务事件灵活触发

## (4) XXL-JOB架构图#

**最新版本架构图：**  
[![](https://img2020.cnblogs.com/blog/2026387/202105/2026387-20210521163712331-662471702.jpg)](https://img2020.cnblogs.com/blog/2026387/202105/2026387-20210521163712331-662471702.jpg)

> **xxl-job其实也是在quartz的基础上实现的，但是修改了任务调度的模式，并且任务调度采用注册和RPC调用方式来实现。**

**管理后台页面：**  
[![](https://img2020.cnblogs.com/blog/2026387/202105/2026387-20210521163711854-1911345214.jpg)](https://img2020.cnblogs.com/blog/2026387/202105/2026387-20210521163711854-1911345214.jpg)

## (5) XXL-JOB原理解析#

2.1.0版本前核心调度模块都是基于`quartz`框架，2.1.0版本开始自研调度组件，移除`quartz`依赖 ，使用时间轮调度。  
(RPC的底层变化， 2.0.1 使用的是Jetty服务的RPC, 2.0.2 使用的Nettty服务的RPC)

### (5.1) 定时触发任务是如何实现的？：使用时间轮实现#

- `xxl_job_info`表是**记录定时任务**的db表，里面有个`trigger_next_time（Long）`字段，表示下一次触发的时间点任务时间被修改 / 每一次任务触发后，可以根据`cronb`表达式计算下一次触发时间戳：  
Date nextValidTime = new CronExpression(jobInfo.getJobCron()).getNextValidTimeAfter(new Date())）  
更新`trigger_next_time`字段
- 定时执行任务逻辑:
1. 定时任务`scheduleThread`：不断从`db`把`5秒`内要执行的任务读出，**立即触发 / 放到时间轮等待触发**，并更新`trigger_next_time`
2. 获取当前时间`now`
3. 轮询`db`，找出`trigger_next_time`在距`now 5秒`内的任务  
3.1 对到达now时间后的任务（超出now 5秒外)  
​ (1) 直接跳过不执行；  
​ (2) 重置`trigger_next_time`  
3.2 对到达`now`时间后的任务（超出`now` 5秒内）  
​ (1) 开线程执行触发逻辑;  
​ (2) 若任务下一次触发时间是在5秒内，则放到时间轮内(Map<Integer, List\>秒数(1-60) => 任务id列表）；  
​ (3) 重置`trigger_next_time`  
3.3 对未到达`now`时间的任务  
​ (1)直接放到时间轮内;  
​ (2)重置`trigger_next_time `
4. 定时任务`ringThread`：时间轮实现到点触发任务  
4.1 时间轮数据结构：`Map<Integer, List<Integer>> key`是秒数`(1-60)` ，`value`是任务`id`列表  
[![](https://img2020.cnblogs.com/blog/2026387/202105/2026387-20210521163711399-2107992911.jpg)](https://img2020.cnblogs.com/blog/2026387/202105/2026387-20210521163711399-2107992911.jpg)
5. 获取当前时间秒数
6. 从时间轮内移出当前秒数前2个秒数（避免处理耗时太长，跨过刻度，向前校验一个刻度）的任务列表id，一一触发任务；

### (5.2) 如何避免集群中的多个服务器同时调度任务？#

当xxl-job应用本身集群部署（实现高可用HA）时，如何避免集群中的多个服务器同时调度任务？  
**通过mysql悲观锁实现分布式锁（for update语句）**

- `setAutoCommit(false)`关闭隐式自动提交事务，启动事务
- `select lock for update`（显式排他锁，其他事务无法进入&无法实现`for update`）
- 读`db`任务信息 -> 拉任务到内存时间轮 -> 更新`db`任务信息
- `commit`提交事务，同时会释放`for update`的排他锁（悲观锁）

### (5.3) 任务执行器注册中心是如何实现的？#

**使用db表xxl\_job\_group记录下执行器的信息：**

> 执行器AppName、执行器名称title、执行器地址列表address\_list(多地址逗号分隔)

### (5.4) 如何实现任务执行器的路由？#

- 执行器集群部署时提供丰富的路由策略，包括：

> 第一个、最后一个、轮询、随机、一致性HASH、最不经常使用、最近最久未使用、故障转移、忙碌转移等；

- **第一个、最后一个、轮询、随机**：都是简单读`address_list`即可
- **一致性HASH**：`TreeSet`实现一致性`hash`算法
- **最不经常使用、最近最久未使用**：`HashMap、LinkedHashMap`
- **故障转移**：遍历`address_list`获取`address`时，逐个检查该`address`的心跳（请求返回状态）；只有心跳正常的`address`才返回使用
- **忙碌转移**：遍历`address_list`获取`address`时，逐个检查该`address`是否忙碌（请求返回状态）；只有状态为`idle`的`address`才返回使用

### (5.5) 如何实现任务分片、并行执行？#

- 拉出任务的执行机器列表，逐个设置`index / total`，把`index / total`分发到任务执行器
- 任务执行器可根据`index / total`参数开发分片任务

## (6)XXL-JOB任务调度流程#

[![](https://img2020.cnblogs.com/blog/2026387/202105/2026387-20210521163710927-1323853600.jpg)](https://img2020.cnblogs.com/blog/2026387/202105/2026387-20210521163710927-1323853600.jpg)

> 1：XXL-Jobadmin平台创建执行器（Job实际执行地址）  
> 2：XXL-Jobadmin平台新建任务，填写对应的执行器  
> 3：Job服务器代码中，使用JobHandler表示该类为Job执行方法  
> 4：当任务执行的时候，会现在XXL-Jobadmin调度平台先执行一次，获取任务中的执行器，然后去对应的执行器地址服务器，执行对应的任务

---

## 轻量级分布式任务调度平台XXL-JOB系列#

> [轻量级分布式任务调度平台(一、 XXL-JOB介绍、原理、工作流程)](https://www.cnblogs.com/MrYuChen-Blog/p/14804019.html)  
> [轻量级分布式任务调度平台(二、XXL-JOB环境搭建集成springboot)](https://www.cnblogs.com/MrYuChen-Blog/p/14804036.html)